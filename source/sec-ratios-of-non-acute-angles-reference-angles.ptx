<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-ratios-of-non-acute-angles-reference-angles">
  <title>Ratios of Non-Acute Angles, Reference Angles</title>
  
  <!-- <introduction>
  <p>
  Introduction
  </p>
  </introduction> -->
  
  <subsection xml:id="subsec-practice-trig-value">
    <title>Exact Values of Trigonometric Ratios (Unit Circle) Practice</title>
    
    <exercises>
      
      <exercise xml:id="practice-trig-value" label="trig-exact-practice">
        <title>Exact Trig-Value Practice</title>
        
        <statement>
          <p>
            Evaluate <m><eval obj="exprTeX"/></m> exactly.
          </p>
          
          <!-- Only the new host id, no legacy host -->
          <div id="trig-exact-practice-controls">&#160;</div>
          
          <p>
            Your answer:
            <fillin ansobj="answerExpr" mode="math" width="8"/>
          </p>
          <p>
            For square roots, type "sqrt", not a decimal approximation
            (for example, type "sqrt(3)", or "sqrt(2)").
          </p>
        </statement>
        
        <setup seed="123">
          <setupScript><![CDATA[
      // === DEFAULTS ===
      const DEFAULT_UNIT  = "deg";  // "deg", "rad", "mix"
      const DEFAULT_TAN   = "no";   // "yes", "no"
      const DEFAULT_WRAP  = "no";   // "yes", "no"  allow negative or > 1 rotation
      const DEFAULT_RECIP = "no";   // "yes", "no"
      const USE_RADIANS   = true;   // keep radians available for "mix"
            
      // Keys
      const KEY_UNIT  = "ptxTrigAngleMode_trig-exact-practice";
      const KEY_TAN   = "ptxTrigIncludeTan_trig-exact-practice";
      const KEY_WRAP  = "ptxTrigAllowWrap_trig-exact-practice";
      const KEY_RECIP = "ptxTrigIncludeRecip_trig-exact-practice";
            
      // Safe localStorage read
      function getPref(key, fallback) {
        try {
          if (typeof window !== "undefined" && window.localStorage) {
            return localStorage.getItem(key) || fallback;
          }
        } catch(_) {}
        return fallback;
      }
            
      const prefUnit  = getPref(KEY_UNIT,  DEFAULT_UNIT);
      const prefTan   = getPref(KEY_TAN,   DEFAULT_TAN);
      const prefWrap  = getPref(KEY_WRAP,  DEFAULT_WRAP);
      const prefRecip = getPref(KEY_RECIP, DEFAULT_RECIP);
            
      // === Exact values ===
      const exact = {
        sin: {
          0: "0", 30: "1/2", 45: "sqrt(2)/2", 60: "sqrt(3)/2", 90: "1",
          120: "sqrt(3)/2", 135: "sqrt(2)/2", 150: "1/2", 180: "0",
          210: "-1/2", 225: "-sqrt(2)/2", 240: "-sqrt(3)/2", 270: "-1",
          300: "-sqrt(3)/2", 315: "-sqrt(2)/2", 330: "-1/2"
        }
      };
            
      exact.cos = {};
      exact.tan = {};
      for (let deg in exact.sin) {
        const s = eval(exact.sin[deg].replace("sqrt", "Math.sqrt"));
        const c = Math.cos(deg * Math.PI / 180);
        const cs = Math.abs(c) < 1e-10 ? "0"
                 : Math.abs(c - 0.5) < 1e-10 ? "1/2"
                 : Math.abs(c - Math.sqrt(2)/2) < 1e-10 ? "sqrt(2)/2"
                 : "sqrt(3)/2";
        exact.cos[deg] = c < 0 ? "-" + cs : cs;
            
        if (Math.abs(c) < 1e-10) {
          exact.tan[deg] = null;
        } else {
          const t = s / c;
          const abs = Math.abs(t);
          const ts = abs < 1e-10 ? "0"
                   : Math.abs(abs - 1) < 1e-10 ? "1"
                   : abs < 1 ? "sqrt(3)/3" : "sqrt(3)";
          exact.tan[deg] = t < 0 ? "-" + ts : ts;
        }
      }
            
      function reciprocal(str) {
        if (!str || str === "0") return null;
        if (str === "1") return "1";
        if (str === "sqrt(3)/3") return "sqrt(3)";
        if (str === "sqrt(3)")   return "sqrt(3)/3";
        if (str === "1/2")       return "2";
        if (str === "sqrt(2)/2") return "sqrt(2)";
        if (str === "sqrt(3)/2") return "2*sqrt(3)/3";
        return str.startsWith("-") ? "-" + reciprocal(str.slice(1)) : "1/(" + str + ")";
      }
      exact.csc = Object.fromEntries(Object.entries(exact.sin).map(([d, s]) => [d, reciprocal(s)]));
      exact.sec = Object.fromEntries(Object.entries(exact.cos).map(([d, s]) => [d, reciprocal(s)]));
      exact.cot = Object.fromEntries(Object.entries(exact.tan).map(([d, s]) => [d, reciprocal(s)]));
            
      // Build function list from prefs
      let funcs = ["sin", "cos"];
      if (prefTan === "yes") funcs.push("tan");
      if (prefRecip === "yes") funcs.push("csc", "sec", "cot");
            
      // Choose function and angle
      const baseAngles = Object.keys(exact.sin).map(Number);
      let func, deg, k, thetaDeg;
            
      do {
        func = funcs[RNG.randInt(0, funcs.length - 1)];
        deg = baseAngles[RNG.randInt(0, baseAngles.length - 1)];
        if (prefWrap === "yes") {
          k = RNG.randInt(-2, 2);
        } else {
          k = 0;
        }
        thetaDeg = deg + 360 * k;
      } while (exact[func][deg] === null);
            
      v.func = func;
      v.answerExpr = exact[func][deg];
            
      function texForDegrees(d) { return d + "^{\\circ}"; }
      function texForRadians(d) {
        const sign = d < 0 ? "-" : "";
        let a = Math.abs(d), b = 180;
        const gcd = (x, y) => y ? gcd(y, x % y) : x;
        const g = gcd(a, b);
        a /= g; b /= g;
        if (a === 0) return "0";
        if (b === 1) return sign + (a === 1 ? "\\pi" : (a + "\\pi"));
        return sign + (a === 1 ? "\\tfrac{\\pi}{" + b + "}" : "\\tfrac{" + a + "\\pi}{" + b + "}");
      }
            
      const funcTeX = {sin:"\\sin", cos:"\\cos", tan:"\\tan", csc:"\\csc", sec:"\\sec", cot:"\\cot"}[func];
            
      let useRad;
      if (prefUnit === "deg") useRad = false;
      else if (prefUnit === "rad") useRad = true;
      else useRad = (USE_RADIANS && RNG.randInt(0,1) === 0);
            
      v.exprTeX = funcTeX + "\\bigl(" + (useRad ? texForRadians(thetaDeg) : texForDegrees(thetaDeg)) + "\\bigr)";
      v.angleTeX = useRad ? texForRadians(thetaDeg) : texForDegrees(thetaDeg);
    ]]>
          </setupScript>
          
          <postRenderScript><![CDATA[
      (function(){
        var ex = document.getElementById("trig-exact-practice");
            
        // Strong cleanup of any legacy UI
        function removeLegacy(){
          if (!ex) return;
            
          // Remove old legacy host entirely
          var oldHost = ex.querySelector("#angle-controls");
          if (oldHost && oldHost.parentNode) oldHost.parentNode.removeChild(oldHost);
            
          // Remove old inputs and their labels if they exist anywhere
          ["#deg-only", "#rad-only"].forEach(function(sel){
            var input = ex.querySelector(sel);
            if (input) {
              var label = input.closest("label");
              if (label && label.parentNode) label.parentNode.removeChild(label);
            }
          });
            
          // Remove any leftover "Angle units:" title and the old note
          var strongs = ex.querySelectorAll("strong");
          strongs.forEach(function(s){
            if (s.textContent.trim().toLowerCase() === "angle units:") {
              // Try to remove its container row if reasonable
              var container = s.parentNode;
              if (container && container.parentNode) {
                container.parentNode.removeChild(container);
              } else {
                s.remove();
              }
            }
          });
          // Remove the old note text if it survived separately
          var spans = ex.querySelectorAll("span");
          spans.forEach(function(sp){
            var t = sp.textContent.trim();
            if (t === " Affects only new questions after you click Randomize." ||
                t === "Affects only new questions after you click Randomize.") {
              if (sp.parentNode) sp.parentNode.removeChild(sp);
            }
          });
        }
            
        // Do cleanup now
        removeLegacy();
            
        // Find or create our new host
        var host = document.getElementById("trig-exact-practice-controls");
        if (!host && ex) {
          host = document.createElement("div");
          host.id = "trig-exact-practice-controls";
          var firstP = ex.querySelector("div.statement p, p");
          if (firstP && firstP.parentNode) {
            firstP.parentNode.insertBefore(host, firstP.nextSibling);
          } else {
            ex.appendChild(host);
          }
        }
        if (!host) return;
            
        // Build the new panel
        var KEY_UNIT  = "ptxTrigAngleMode_trig-exact-practice";
        var KEY_TAN   = "ptxTrigIncludeTan_trig-exact-practice";
        var KEY_WRAP  = "ptxTrigAllowWrap_trig-exact-practice";
        var KEY_RECIP = "ptxTrigIncludeRecip_trig-exact-practice";
        var DEFAULT_UNIT  = "deg";
        var DEFAULT_TAN   = "no";
        var DEFAULT_WRAP  = "no";
        var DEFAULT_RECIP = "no";
            
        function get(key, dflt){ try { return localStorage.getItem(key) || dflt; } catch(_) { return dflt; } }
        function set(key, val){ try { localStorage.setItem(key, val); } catch(_) {} }
            
        function radio(name, id, labelText){
          var label = document.createElement("label");
          label.style.cursor = "pointer";
          var input = document.createElement("input");
          input.type = "radio";
          input.name = name;
          input.id = id;
          input.style.marginRight = "0.35rem";
          label.appendChild(input);
          label.appendChild(document.createTextNode(labelText));
          return {label: label, input: input};
        }
        function checkbox(id, text){
          var label = document.createElement("label");
          label.style.cursor = "pointer";
          var input = document.createElement("input");
          input.type = "checkbox";
          input.id = id;
          input.style.marginRight = "0.35rem";
          label.appendChild(input);
          label.appendChild(document.createTextNode(text));
          return {label: label, input: input};
        }
            
        host.innerHTML = "";
        var panel = document.createElement("div");
        panel.setAttribute("data-ptx-trig-ui", "1");
        panel.style.display = "grid";
        panel.style.gap = "0.5rem";
        panel.style.margin = "0.25rem 0 0.5rem";
            
        var unitTitle = document.createElement("strong");
        unitTitle.textContent = "Units: ";
        var unitWrap = document.createElement("div");
        unitWrap.style.display = "flex";
        unitWrap.style.gap = "1rem";
        var rDeg = radio("unit-mode", "unit-deg", "Degrees only");
        var rRad = radio("unit-mode", "unit-rad", "Radians only");
        var rMix = radio("unit-mode", "unit-mix", "Mixed");
        unitWrap.appendChild(rDeg.label);
        unitWrap.appendChild(rRad.label);
        unitWrap.appendChild(rMix.label);
            
        var optTitle = document.createElement("strong");
        optTitle.textContent = "Options: ";
        var cbTan   = checkbox("opt-tan",   "Include tangent");
        var cbWrap  = checkbox("opt-wrap",  "Allow negative or more than one full rotation");
        var cbRecip = checkbox("opt-recip", "Include reciprocal functions");
        var optWrap = document.createElement("div");
        optWrap.style.display = "flex";
        optWrap.style.gap = "1rem";
        optWrap.style.flexWrap = "wrap";
        optWrap.appendChild(cbTan.label);
        optWrap.appendChild(cbWrap.label);
        optWrap.appendChild(cbRecip.label);
            
        var note = document.createElement("span");
        note.style.opacity = "0.8";
        note.style.fontStyle = "italic";
        note.textContent = " These settings affect only new questions after you click Randomize.";
            
        panel.appendChild(unitTitle);
        panel.appendChild(unitWrap);
        panel.appendChild(optTitle);
        panel.appendChild(optWrap);
        panel.appendChild(note);
        host.appendChild(panel);
            
        // Load saved values and apply defaults
        var unit = get(KEY_UNIT, DEFAULT_UNIT);
        if (unit === "rad") rRad.input.checked = true;
        else if (unit === "mix") rMix.input.checked = true;
        else rDeg.input.checked = true;
            
        cbTan.input.checked   = get(KEY_TAN,   DEFAULT_TAN)   === "yes";
        cbWrap.input.checked  = get(KEY_WRAP,  DEFAULT_WRAP)  === "yes";
        cbRecip.input.checked = get(KEY_RECIP, DEFAULT_RECIP) === "yes";
            
        // Save on change
        rDeg.input.addEventListener("change", function(){ if (rDeg.input.checked) set(KEY_UNIT, "deg"); });
        rRad.input.addEventListener("change", function(){ if (rRad.input.checked) set(KEY_UNIT, "rad"); });
        rMix.input.addEventListener("change", function(){ if (rMix.input.checked) set(KEY_UNIT, "mix"); });
        cbTan.input.addEventListener("change",   function(){ set(KEY_TAN,   cbTan.input.checked   ? "yes" : "no"); });
        cbWrap.input.addEventListener("change",  function(){ set(KEY_WRAP,  cbWrap.input.checked  ? "yes" : "no"); });
        cbRecip.input.addEventListener("change", function(){ set(KEY_RECIP, cbRecip.input.checked ? "yes" : "no"); });
            
        // Run cleanup once more shortly after load to beat any late legacy script
        setTimeout(removeLegacy, 60);
      })();
    ]]>
          </postRenderScript>
        </setup>
        
        <evaluation>
          <evaluate>
            <test correct="yes">
              <mathcmp use-answer="yes"/>
              <feedback><p>Correct, great work 🎉</p></feedback>
            </test>
            <test>
              <feedback><p>Not quite. Use an exact radical value like <m>\sqrt{3}/2</m>, not a decimal.</p></feedback>
            </test>
          </evaluate>
        </evaluation>
        
        <solution>
          <p>
            The exact value is
            <math>\ <eval obj="func"/> \!\bigl(<eval obj="angleTeX"/>\bigr) = <eval obj="answerExpr"/></math>.
          </p>
        </solution>
      </exercise>
      
    </exercises>
    
    <exercises xml:id="exercises-working-version">
      
    </exercises>    
  </subsection>
  
  
</section>
